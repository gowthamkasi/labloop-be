/**\n * Authentication Middleware\n * JWT token validation and user authentication for protected routes\n */\n\nimport { FastifyRequest, FastifyReply } from 'fastify';\nimport { container, TYPES } from '@/config/Container.js';\nimport { TokenService } from '@/domain/user/services/TokenService.js';\nimport { InvalidTokenError, UnauthorizedAccessError } from '@/domain/user/exceptions/index.js';\nimport { ILogger } from '@/shared/utils/Logger.js';\nimport { HttpStatus } from '@/shared/constants/HttpStatus.js';\n\n// Extend FastifyRequest to include user information\ndeclare module 'fastify' {\n  interface FastifyRequest {\n    user?: {\n      userId: string;\n      email: string;\n      role: string;\n      labId?: string;\n      hospitalId?: string;\n      permissions?: any;\n    };\n  }\n}\n\nexport interface AuthenticationOptions {\n  required?: boolean; // If false, allows unauthenticated access but populates user if token present\n  allowedRoles?: string[];\n  requireLabAccess?: boolean;\n  requireHospitalAccess?: boolean;\n}\n\nexport class AuthenticationMiddleware {\n  private tokenService: TokenService;\n  private logger: ILogger;\n\n  constructor() {\n    this.tokenService = container.get<TokenService>(TYPES.TokenService);\n    this.logger = container.get<ILogger>(TYPES.Logger);\n  }\n\n  /**\n   * JWT Authentication middleware for API routes\n   */\n  public authenticate(options: AuthenticationOptions = { required: true }) {\n    return async (request: FastifyRequest, reply: FastifyReply) => {\n      try {\n        const token = this.extractToken(request);\n\n        if (!token) {\n          if (options.required) {\n            this.logger.warn('Authentication failed - no token provided', {\n              path: request.url,\n              method: request.method,\n              ip: request.ip\n            });\n            return reply.status(HttpStatus.UNAUTHORIZED).send({\n              error: 'Authentication required',\n              details: 'Access token is required'\n            });\n          }\n          return; // Continue without authentication if not required\n        }\n\n        // Verify and decode token\n        const payload = this.tokenService.verifyAccessToken(token);\n\n        // Validate healthcare token for additional security\n        const healthcareValidation = this.tokenService.validateHealthcareToken(token);\n        if (!healthcareValidation.valid) {\n          this.logger.warn('Invalid healthcare token', {\n            userId: payload.userId,\n            warnings: healthcareValidation.warnings\n          });\n          \n          if (options.required) {\n            return reply.status(HttpStatus.UNAUTHORIZED).send({\n              error: 'Invalid token',\n              details: 'Token validation failed'\n            });\n          }\n          return;\n        }\n\n        // Check role-based access if specified\n        if (options.allowedRoles && !options.allowedRoles.includes(payload.role)) {\n          this.logger.warn('Access denied - insufficient role', {\n            userId: payload.userId,\n            userRole: payload.role,\n            requiredRoles: options.allowedRoles,\n            path: request.url\n          });\n          \n          return reply.status(HttpStatus.FORBIDDEN).send({\n            error: 'Insufficient permissions',\n            details: 'Your role does not have access to this resource'\n          });\n        }\n\n        // Check lab access if required\n        if (options.requireLabAccess && payload.role !== 'admin' && !payload.labId) {\n          this.logger.warn('Access denied - no lab assignment', {\n            userId: payload.userId,\n            path: request.url\n          });\n          \n          return reply.status(HttpStatus.FORBIDDEN).send({\n            error: 'Lab access required',\n            details: 'User must be assigned to a lab'\n          });\n        }\n\n        // Check hospital access if required\n        if (options.requireHospitalAccess && payload.role !== 'admin' && !payload.hospitalId) {\n          this.logger.warn('Access denied - no hospital assignment', {\n            userId: payload.userId,\n            path: request.url\n          });\n          \n          return reply.status(HttpStatus.FORBIDDEN).send({\n            error: 'Hospital access required',\n            details: 'User must be assigned to a hospital'\n          });\n        }\n\n        // Attach user information to request\n        request.user = {\n          userId: payload.userId,\n          email: payload.email,\n          role: payload.role,\n          labId: payload.labId,\n          hospitalId: payload.hospitalId,\n          permissions: healthcareValidation.payload\n        };\n\n        // Log successful authentication\n        this.logger.info('Authentication successful', {\n          userId: payload.userId,\n          role: payload.role,\n          path: request.url,\n          method: request.method,\n          securityLevel: healthcareValidation.securityLevel\n        });\n\n        // Add security warnings to response headers if any\n        if (healthcareValidation.warnings.length > 0) {\n          reply.header('X-Security-Warnings', healthcareValidation.warnings.join('; '));\n        }\n\n      } catch (error) {\n        this.logger.error('Authentication error', {\n          error: error instanceof Error ? error.message : 'Unknown error',\n          path: request.url,\n          method: request.method,\n          ip: request.ip\n        });\n\n        if (error instanceof InvalidTokenError || error instanceof UnauthorizedAccessError) {\n          return reply.status(HttpStatus.UNAUTHORIZED).send({\n            error: 'Authentication failed',\n            details: error.message\n          });\n        }\n\n        return reply.status(HttpStatus.INTERNAL_SERVER_ERROR).send({\n          error: 'Authentication error',\n          details: 'An error occurred during authentication'\n        });\n      }\n    };\n  }\n\n  /**\n   * Session-based authentication middleware for web routes\n   */\n  public authenticateSession(options: AuthenticationOptions = { required: true }) {\n    return async (request: FastifyRequest, reply: FastifyReply) => {\n      try {\n        // For session-based auth, check for session cookie or session data\n        const sessionToken = request.cookies.refreshToken;\n        \n        if (!sessionToken) {\n          if (options.required) {\n            return reply.status(HttpStatus.UNAUTHORIZED).send({\n              authenticated: false,\n              error: 'Session required'\n            });\n          }\n          return;\n        }\n\n        // Validate session token (refresh token used as session identifier)\n        const validation = this.tokenService.validateRefreshToken(sessionToken);\n        if (!validation.valid) {\n          if (options.required) {\n            return reply.status(HttpStatus.UNAUTHORIZED).send({\n              authenticated: false,\n              error: 'Invalid session'\n            });\n          }\n          return;\n        }\n\n        // For session auth, we might need to fetch user data from database\n        // This is a simplified version - in real implementation, \n        // you'd fetch user data and validate session\n        \n        this.logger.info('Session authentication successful', {\n          userId: validation.userId,\n          path: request.url\n        });\n\n      } catch (error) {\n        this.logger.error('Session authentication error', error as Error);\n        \n        if (options.required) {\n          return reply.status(HttpStatus.UNAUTHORIZED).send({\n            authenticated: false,\n            error: 'Session validation failed'\n          });\n        }\n      }\n    };\n  }\n\n  /**\n   * API Key authentication middleware for system-to-system communication\n   */\n  public authenticateApiKey() {\n    return async (request: FastifyRequest, reply: FastifyReply) => {\n      try {\n        const apiKey = request.headers['x-api-key'] as string;\n        \n        if (!apiKey) {\n          return reply.status(HttpStatus.UNAUTHORIZED).send({\n            error: 'API key required',\n            details: 'X-API-Key header is required'\n          });\n        }\n\n        const validation = this.tokenService.verifyApiKey(apiKey);\n        if (!validation.valid) {\n          this.logger.warn('Invalid API key', {\n            apiKey: apiKey.substring(0, 10) + '...',\n            path: request.url,\n            ip: request.ip\n          });\n          \n          return reply.status(HttpStatus.UNAUTHORIZED).send({\n            error: 'Invalid API key',\n            details: 'The provided API key is invalid'\n          });\n        }\n\n        // Attach system information to request\n        (request as any).system = {\n          systemId: validation.systemId,\n          permissions: validation.permissions\n        };\n\n        this.logger.info('API key authentication successful', {\n          systemId: validation.systemId,\n          path: request.url\n        });\n\n      } catch (error) {\n        this.logger.error('API key authentication error', error as Error);\n        \n        return reply.status(HttpStatus.UNAUTHORIZED).send({\n          error: 'API key validation failed',\n          details: 'An error occurred during API key validation'\n        });\n      }\n    };\n  }\n\n  /**\n   * Extract JWT token from request headers or cookies\n   */\n  private extractToken(request: FastifyRequest): string | null {\n    // Check Authorization header (Bearer token)\n    const authHeader = request.headers.authorization;\n    if (authHeader && authHeader.startsWith('Bearer ')) {\n      return authHeader.substring(7);\n    }\n\n    // Check query parameter (for WebSocket or special cases)\n    const queryToken = (request.query as any)?.token;\n    if (queryToken && typeof queryToken === 'string') {\n      return queryToken;\n    }\n\n    // Check cookie (for web sessions)\n    const cookieToken = request.cookies?.accessToken;\n    if (cookieToken) {\n      return cookieToken;\n    }\n\n    return null;\n  }\n\n  /**\n   * Create authentication preHandler that can be used directly with Fastify routes\n   */\n  public static createPreHandler(options?: AuthenticationOptions) {\n    const middleware = new AuthenticationMiddleware();\n    return middleware.authenticate(options);\n  }\n\n  /**\n   * Create session authentication preHandler\n   */\n  public static createSessionPreHandler(options?: AuthenticationOptions) {\n    const middleware = new AuthenticationMiddleware();\n    return middleware.authenticateSession(options);\n  }\n\n  /**\n   * Create API key authentication preHandler\n   */\n  public static createApiKeyPreHandler() {\n    const middleware = new AuthenticationMiddleware();\n    return middleware.authenticateApiKey();\n  }\n}"