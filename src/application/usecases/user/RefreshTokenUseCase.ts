/**\n * Refresh Token Use Case\n * Handles JWT token refresh for continued authentication\n */\n\nimport { inject, injectable } from 'inversify';\nimport { TYPES } from '@/config/Container.js';\nimport { IUserRepository } from '@/application/interfaces/repositories/IUserRepository.js';\nimport { UserAggregate } from '@/domain/user/UserAggregate.js';\nimport { \n  InvalidTokenError, \n  UserNotFoundError, \n  UnauthorizedAccessError \n} from '@/domain/user/exceptions/index.js';\nimport { ITokenService } from './LoginUseCase.js';\nimport { ILogger } from '@/shared/utils/Logger.js';\n\nexport interface RefreshTokenRequest {\n  refreshToken: string;\n  userId?: string; // Optional for additional validation\n}\n\nexport interface RefreshTokenResponse {\n  success: boolean;\n  data: {\n    accessToken: string;\n    refreshToken: string;\n    expiresIn: number;\n  };\n  message: string;\n}\n\nexport interface ITokenValidator {\n  validateRefreshToken(token: string): { valid: boolean; userId?: string; error?: string };\n  isTokenExpired(token: string): boolean;\n}\n\n@injectable()\nexport class RefreshTokenUseCase {\n  constructor(\n    @inject(TYPES.UserRepository) private userRepository: IUserRepository,\n    @inject(TYPES.TokenService) private tokenService: ITokenService,\n    @inject(TYPES.TokenValidator) private tokenValidator: ITokenValidator,\n    @inject(TYPES.Logger) private logger: ILogger\n  ) {}\n\n  public async execute(request: RefreshTokenRequest): Promise<RefreshTokenResponse> {\n    this.logger.info('Token refresh attempt', {\n      hasRefreshToken: !!request.refreshToken,\n      userId: request.userId\n    });\n\n    try {\n      // Validate request\n      this.validateRequest(request);\n\n      // Validate refresh token format and extract user ID\n      const tokenValidation = this.tokenValidator.validateRefreshToken(request.refreshToken);\n      if (!tokenValidation.valid || !tokenValidation.userId) {\n        this.logger.warn('Invalid refresh token format', {\n          error: tokenValidation.error\n        });\n        throw new InvalidTokenError('Invalid refresh token');\n      }\n\n      // Additional validation if userId provided in request\n      if (request.userId && request.userId !== tokenValidation.userId) {\n        this.logger.warn('Token user ID mismatch', {\n          requestUserId: request.userId,\n          tokenUserId: tokenValidation.userId\n        });\n        throw new InvalidTokenError('Token user mismatch');\n      }\n\n      // Check if token is expired\n      if (this.tokenValidator.isTokenExpired(request.refreshToken)) {\n        this.logger.warn('Expired refresh token', {\n          userId: tokenValidation.userId\n        });\n        throw new InvalidTokenError('Refresh token has expired');\n      }\n\n      // Find user\n      const userEntity = await this.userRepository.findById(tokenValidation.userId);\n      if (!userEntity) {\n        this.logger.warn('User not found for token refresh', {\n          userId: tokenValidation.userId\n        });\n        throw new UserNotFoundError(tokenValidation.userId);\n      }\n\n      // Create user aggregate\n      const userAggregate = UserAggregate.fromEntity(userEntity);\n\n      // Check if user can still login (active, not locked)\n      if (!userAggregate.user.canLogin()) {\n        this.logger.warn('Token refresh denied - user cannot login', {\n          userId: tokenValidation.userId,\n          isActive: userEntity.isActive,\n          isVerified: userEntity.isVerified,\n          isLocked: userEntity.accountLockedUntil\n        });\n        throw new UnauthorizedAccessError('User account is not active');\n      }\n\n      // Verify refresh token exists in user's token list\n      if (!userEntity.refreshTokens.includes(request.refreshToken)) {\n        this.logger.warn('Refresh token not found in user tokens', {\n          userId: tokenValidation.userId\n        });\n        throw new InvalidTokenError('Invalid refresh token');\n      }\n\n      // Generate new tokens\n      const newAccessToken = this.tokenService.generateAccessToken(\n        userEntity._id,\n        userEntity.role\n      );\n      const newRefreshToken = this.tokenService.generateRefreshToken(userEntity._id);\n\n      // Remove old refresh token and add new one\n      userAggregate.removeRefreshToken(request.refreshToken);\n      userAggregate.addRefreshToken(newRefreshToken);\n\n      // Save changes\n      await this.userRepository.save(userAggregate.toPlainObject());\n\n      this.logger.info('Token refresh successful', {\n        userId: tokenValidation.userId\n      });\n\n      return {\n        success: true,\n        data: {\n          accessToken: newAccessToken,\n          refreshToken: newRefreshToken,\n          expiresIn: this.tokenService.getTokenExpiry()\n        },\n        message: 'Token refreshed successfully'\n      };\n\n    } catch (error) {\n      this.logger.error('Token refresh failed', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        userId: request.userId\n      });\n      \n      throw error;\n    }\n  }\n\n  private validateRequest(request: RefreshTokenRequest): void {\n    if (!request.refreshToken?.trim()) {\n      throw new InvalidTokenError('Refresh token is required');\n    }\n  }\n\n  // Helper method for automatic token cleanup\n  public async cleanupExpiredTokens(userId: string): Promise<void> {\n    this.logger.info('Cleaning up expired tokens', { userId });\n\n    try {\n      const userEntity = await this.userRepository.findById(userId);\n      if (!userEntity) {\n        return;\n      }\n\n      const userAggregate = UserAggregate.fromEntity(userEntity);\n      const validTokens: string[] = [];\n\n      // Check each refresh token\n      for (const token of userEntity.refreshTokens) {\n        if (!this.tokenValidator.isTokenExpired(token)) {\n          validTokens.push(token);\n        }\n      }\n\n      // Update user with only valid tokens\n      if (validTokens.length !== userEntity.refreshTokens.length) {\n        userAggregate.user.refreshTokens = validTokens;\n        userAggregate.markDirty();\n        await this.userRepository.save(userAggregate.toPlainObject());\n        \n        this.logger.info('Cleaned up expired tokens', {\n          userId,\n          removed: userEntity.refreshTokens.length - validTokens.length,\n          remaining: validTokens.length\n        });\n      }\n\n    } catch (error) {\n      this.logger.error('Token cleanup failed', {\n        userId,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n\n  // Helper method for bulk token cleanup (for maintenance)\n  public async cleanupAllExpiredTokens(): Promise<{ cleaned: number; errors: number }> {\n    this.logger.info('Starting bulk token cleanup');\n    \n    let cleaned = 0;\n    let errors = 0;\n\n    try {\n      // This would typically be done in batches\n      const users = await this.userRepository.findAll({ \n        isActive: true,\n        'refreshTokens.0': { $exists: true } // Users with at least one refresh token\n      });\n\n      for (const user of users) {\n        try {\n          await this.cleanupExpiredTokens(user._id);\n          cleaned++;\n        } catch (error) {\n          errors++;\n          this.logger.error('Failed to cleanup tokens for user', {\n            userId: user._id,\n            error: error instanceof Error ? error.message : 'Unknown error'\n          });\n        }\n      }\n\n      this.logger.info('Bulk token cleanup completed', { cleaned, errors });\n\n    } catch (error) {\n      this.logger.error('Bulk token cleanup failed', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n\n    return { cleaned, errors };\n  }\n}"