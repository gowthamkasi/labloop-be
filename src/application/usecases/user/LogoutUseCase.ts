/**\n * Logout Use Case\n * Handles user logout and token invalidation\n */\n\nimport { inject, injectable } from 'inversify';\nimport { TYPES } from '@/config/Container.js';\nimport { IUserRepository } from '@/application/interfaces/repositories/IUserRepository.js';\nimport { UserAggregate } from '@/domain/user/UserAggregate.js';\nimport { UserNotFoundError, InvalidTokenError } from '@/domain/user/exceptions/index.js';\nimport { ILogger } from '@/shared/utils/Logger.js';\n\nexport interface LogoutRequest {\n  userId: string;\n  refreshToken?: string;\n  logoutAll?: boolean; // Logout from all devices\n}\n\nexport interface LogoutResponse {\n  success: boolean;\n  message: string;\n}\n\n@injectable()\nexport class LogoutUseCase {\n  constructor(\n    @inject(TYPES.UserRepository) private userRepository: IUserRepository,\n    @inject(TYPES.Logger) private logger: ILogger\n  ) {}\n\n  public async execute(request: LogoutRequest): Promise<LogoutResponse> {\n    this.logger.info('Logout attempt', {\n      userId: request.userId,\n      logoutAll: request.logoutAll\n    });\n\n    try {\n      // Validate request\n      this.validateRequest(request);\n\n      // Find user\n      const userEntity = await this.userRepository.findById(request.userId);\n      if (!userEntity) {\n        throw new UserNotFoundError(request.userId);\n      }\n\n      // Create user aggregate\n      const userAggregate = UserAggregate.fromEntity(userEntity);\n\n      if (request.logoutAll) {\n        // Clear all refresh tokens (logout from all devices)\n        userAggregate.clearAllRefreshTokens();\n        \n        this.logger.info('User logged out from all devices', {\n          userId: request.userId\n        });\n        \n      } else if (request.refreshToken) {\n        // Remove specific refresh token\n        userAggregate.removeRefreshToken(request.refreshToken);\n        \n        this.logger.info('User logged out from single device', {\n          userId: request.userId\n        });\n        \n      } else {\n        // If no refresh token provided but not logout all, clear all tokens\n        userAggregate.clearAllRefreshTokens();\n        \n        this.logger.info('User logged out - no refresh token provided, cleared all', {\n          userId: request.userId\n        });\n      }\n\n      // Save changes\n      await this.userRepository.save(userAggregate.toPlainObject());\n\n      return {\n        success: true,\n        message: 'Logged out successfully'\n      };\n\n    } catch (error) {\n      this.logger.error('Logout failed', {\n        userId: request.userId,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      \n      throw error;\n    }\n  }\n\n  private validateRequest(request: LogoutRequest): void {\n    if (!request.userId?.trim()) {\n      throw new InvalidTokenError('User ID is required');\n    }\n  }\n\n  // Helper method for session-based logout (web)\n  public async executeSessionLogout(userId: string): Promise<LogoutResponse> {\n    return this.execute({\n      userId,\n      logoutAll: false\n    });\n  }\n\n  // Helper method for mobile logout\n  public async executeMobileLogout(\n    userId: string, \n    refreshToken: string\n  ): Promise<LogoutResponse> {\n    return this.execute({\n      userId,\n      refreshToken,\n      logoutAll: false\n    });\n  }\n\n  // Helper method for admin-forced logout\n  public async forceLogout(\n    targetUserId: string,\n    adminUserId: string\n  ): Promise<LogoutResponse> {\n    this.logger.info('Admin forced logout', {\n      targetUserId,\n      adminUserId\n    });\n\n    return this.execute({\n      userId: targetUserId,\n      logoutAll: true\n    });\n  }\n}"