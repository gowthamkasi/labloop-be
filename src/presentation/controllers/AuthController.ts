/**\n * Authentication Controller\n * Handles authentication endpoints for web and mobile applications\n */\n\nimport { FastifyRequest, FastifyReply } from 'fastify';\nimport { inject, injectable } from 'inversify';\nimport { TYPES } from '@/config/Container.js';\nimport { LoginUseCase, LoginRequest } from '@/application/usecases/user/LoginUseCase.js';\nimport { LogoutUseCase } from '@/application/usecases/user/LogoutUseCase.js';\nimport { RefreshTokenUseCase } from '@/application/usecases/user/RefreshTokenUseCase.js';\nimport { \n  InvalidCredentialsError,\n  AccountLockedError,\n  UnauthorizedAccessError,\n  InvalidTokenError\n} from '@/domain/user/exceptions/index.js';\nimport { ILogger } from '@/shared/utils/Logger.js';\nimport { HttpStatus } from '@/shared/constants/HttpStatus.js';\n\n// Request/Response interfaces\ninterface LoginRequestBody {\n  email: string;\n  password: string;\n}\n\ninterface MobileLoginRequestBody extends LoginRequestBody {\n  deviceId?: string;\n  deviceName?: string;\n  platform?: 'ios' | 'android';\n  fcmToken?: string;\n  biometricEnabled?: boolean;\n}\n\ninterface RefreshTokenRequestBody {\n  refreshToken: string;\n}\n\n@injectable()\nexport class AuthController {\n  constructor(\n    @inject(TYPES.LoginUseCase) private loginUseCase: LoginUseCase,\n    @inject(TYPES.LogoutUseCase) private logoutUseCase: LogoutUseCase,\n    @inject(TYPES.RefreshTokenUseCase) private refreshTokenUseCase: RefreshTokenUseCase,\n    @inject(TYPES.Logger) private logger: ILogger\n  ) {}\n\n  /**\n   * POST /auth/login - Web application login\n   */\n  public async login(\n    request: FastifyRequest<{ Body: LoginRequestBody }>,\n    reply: FastifyReply\n  ): Promise<void> {\n    try {\n      const { email, password } = request.body;\n      const clientIP = request.ip;\n      const userAgent = request.headers['user-agent'];\n\n      const loginRequest: LoginRequest = {\n        email,\n        password,\n        ipAddress: clientIP,\n        userAgent,\n        platform: 'web'\n      };\n\n      const result = await this.loginUseCase.execute(loginRequest);\n\n      // Set HTTP-only cookie for web sessions (optional for session-based auth)\n      reply.setCookie('refreshToken', result.tokens.refreshToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days\n        path: '/'\n      });\n\n      // Return response without refresh token in body (it's in cookie)\n      reply.status(HttpStatus.OK).send({\n        user: result.user,\n        token: result.tokens.accessToken,\n        expiresIn: result.tokens.expiresIn,\n        message: result.message\n      });\n\n    } catch (error) {\n      this.handleAuthError(error, reply);\n    }\n  }\n\n  /**\n   * POST /auth/logout - Web application logout\n   */\n  public async logout(\n    request: FastifyRequest,\n    reply: FastifyReply\n  ): Promise<void> {\n    try {\n      const userId = (request as any).user?.userId;\n      const refreshToken = request.cookies.refreshToken;\n\n      if (userId) {\n        await this.logoutUseCase.execute({\n          userId,\n          refreshToken\n        });\n      }\n\n      // Clear refresh token cookie\n      reply.clearCookie('refreshToken', { path: '/' });\n\n      reply.status(HttpStatus.OK).send({\n        message: 'Logged out successfully'\n      });\n\n    } catch (error) {\n      this.logger.error('Logout error', error as Error);\n      reply.status(HttpStatus.INTERNAL_SERVER_ERROR).send({\n        error: 'Logout failed',\n        details: 'An error occurred during logout'\n      });\n    }\n  }\n\n  /**\n   * GET /auth/verify - Verify session/token validity\n   */\n  public async verify(\n    request: FastifyRequest,\n    reply: FastifyReply\n  ): Promise<void> {\n    try {\n      // This endpoint is typically protected by auth middleware\n      // If we reach here, the token is valid\n      const user = (request as any).user;\n\n      reply.status(HttpStatus.OK).send({\n        authenticated: true,\n        user: {\n          _id: user.userId,\n          email: user.email,\n          role: user.role,\n          labId: user.labId,\n          hospitalId: user.hospitalId\n        }\n      });\n\n    } catch (error) {\n      reply.status(HttpStatus.UNAUTHORIZED).send({\n        authenticated: false,\n        error: 'Invalid or expired token'\n      });\n    }\n  }\n\n  /**\n   * POST /mobile/auth/login - Mobile application login\n   */\n  public async mobileLogin(\n    request: FastifyRequest<{ Body: MobileLoginRequestBody }>,\n    reply: FastifyReply\n  ): Promise<void> {\n    try {\n      const { \n        email, \n        password, \n        deviceId, \n        deviceName, \n        platform, \n        fcmToken,\n        biometricEnabled \n      } = request.body;\n      \n      const clientIP = request.ip;\n      const userAgent = request.headers['user-agent'];\n\n      const loginRequest: LoginRequest = {\n        email,\n        password,\n        ipAddress: clientIP,\n        userAgent,\n        platform: platform || 'mobile',\n        deviceId,\n        deviceName\n      };\n\n      const result = await this.loginUseCase.executeMobileLogin(loginRequest);\n\n      // Log mobile-specific data\n      if (fcmToken) {\n        this.logger.info('Mobile login with FCM token', {\n          userId: result.data.user.id,\n          platform,\n          biometricEnabled\n        });\n        // TODO: Store FCM token for push notifications\n      }\n\n      reply.status(HttpStatus.OK).send(result);\n\n    } catch (error) {\n      this.handleMobileAuthError(error, reply);\n    }\n  }\n\n  /**\n   * POST /mobile/auth/logout - Mobile application logout\n   */\n  public async mobileLogout(\n    request: FastifyRequest<{ Body: { refreshToken?: string } }>,\n    reply: FastifyReply\n  ): Promise<void> {\n    try {\n      const userId = (request as any).user?.userId;\n      const { refreshToken } = request.body;\n\n      if (userId) {\n        await this.logoutUseCase.executeMobileLogout(userId, refreshToken || '');\n      }\n\n      reply.status(HttpStatus.OK).send({\n        success: true,\n        message: 'Logged out successfully'\n      });\n\n    } catch (error) {\n      this.logger.error('Mobile logout error', error as Error);\n      reply.status(HttpStatus.OK).send({\n        success: true,\n        message: 'Logged out successfully' // Always return success for logout\n      });\n    }\n  }\n\n  /**\n   * POST /mobile/auth/refresh - Refresh access token\n   */\n  public async refreshToken(\n    request: FastifyRequest<{ Body: RefreshTokenRequestBody }>,\n    reply: FastifyReply\n  ): Promise<void> {\n    try {\n      const { refreshToken } = request.body;\n\n      const result = await this.refreshTokenUseCase.execute({ refreshToken });\n\n      reply.status(HttpStatus.OK).send({\n        success: true,\n        data: {\n          accessToken: result.data.accessToken,\n          refreshToken: result.data.refreshToken,\n          expiresIn: result.data.expiresIn\n        },\n        message: result.message\n      });\n\n    } catch (error) {\n      this.handleTokenRefreshError(error, reply);\n    }\n  }\n\n  /**\n   * GET /mobile/auth/profile - Get current user profile (mobile)\n   */\n  public async getMobileProfile(\n    request: FastifyRequest,\n    reply: FastifyReply\n  ): Promise<void> {\n    try {\n      // This endpoint is protected by auth middleware\n      const user = (request as any).user;\n\n      // TODO: Fetch complete user profile from repository\n      reply.status(HttpStatus.OK).send({\n        success: true,\n        data: {\n          id: user.userId,\n          email: user.email,\n          role: user.role,\n          profile: {\n            // Profile data would come from user repository\n          },\n          healthProfile: {\n            // Health profile data would come from patient data if linked\n          }\n        }\n      });\n\n    } catch (error) {\n      this.logger.error('Get mobile profile error', error as Error);\n      reply.status(HttpStatus.INTERNAL_SERVER_ERROR).send({\n        success: false,\n        error: 'Failed to get profile'\n      });\n    }\n  }\n\n  // Error handling methods\n  private handleAuthError(error: unknown, reply: FastifyReply): void {\n    if (error instanceof InvalidCredentialsError) {\n      reply.status(HttpStatus.UNAUTHORIZED).send({\n        error: 'Invalid credentials',\n        details: 'Invalid email or password'\n      });\n    } else if (error instanceof AccountLockedError) {\n      reply.status(HttpStatus.LOCKED).send({\n        error: 'Account locked',\n        details: 'Account is temporarily locked due to multiple failed login attempts'\n      });\n    } else if (error instanceof UnauthorizedAccessError) {\n      reply.status(HttpStatus.UNAUTHORIZED).send({\n        error: 'Unauthorized access',\n        details: error.message\n      });\n    } else {\n      this.logger.error('Login error', error as Error);\n      reply.status(HttpStatus.INTERNAL_SERVER_ERROR).send({\n        error: 'Internal server error',\n        details: 'An error occurred during login'\n      });\n    }\n  }\n\n  private handleMobileAuthError(error: unknown, reply: FastifyReply): void {\n    if (error instanceof InvalidCredentialsError) {\n      reply.status(HttpStatus.UNAUTHORIZED).send({\n        success: false,\n        error: 'Invalid credentials',\n        message: 'Invalid email or password',\n        timestamp: new Date().toISOString()\n      });\n    } else if (error instanceof AccountLockedError) {\n      reply.status(HttpStatus.LOCKED).send({\n        success: false,\n        error: 'Account locked',\n        message: 'Account is temporarily locked',\n        timestamp: new Date().toISOString()\n      });\n    } else {\n      this.logger.error('Mobile login error', error as Error);\n      reply.status(HttpStatus.INTERNAL_SERVER_ERROR).send({\n        success: false,\n        error: 'Internal server error',\n        message: 'An error occurred during login',\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n\n  private handleTokenRefreshError(error: unknown, reply: FastifyReply): void {\n    if (error instanceof InvalidTokenError) {\n      reply.status(HttpStatus.UNAUTHORIZED).send({\n        success: false,\n        error: 'Invalid token',\n        message: error.message\n      });\n    } else {\n      this.logger.error('Token refresh error', error as Error);\n      reply.status(HttpStatus.INTERNAL_SERVER_ERROR).send({\n        success: false,\n        error: 'Token refresh failed',\n        message: 'An error occurred during token refresh'\n      });\n    }\n  }\n\n  // CORS preflight handler for mobile endpoints\n  public async handleOptions(\n    request: FastifyRequest,\n    reply: FastifyReply\n  ): Promise<void> {\n    reply.status(HttpStatus.OK).send();\n  }\n}"